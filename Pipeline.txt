analyse.component.ts :
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup } from '@angular/forms';
import { AnalysisService } from '../../services/analysis.service';
import { FileUploadComponent } from '../../components/file-upload/file-upload.component';
import { ResultsTableComponent } from '../../components/results-table/results-table.component';

@Component({
  selector: 'app-analysis',
  standalone: true,
  templateUrl: "./analysis.component.html",
  styleUrl: "./analysis.component.css",
  imports: [CommonModule, ReactiveFormsModule, FileUploadComponent, ResultsTableComponent],
})
export class AnalysisComponent implements OnInit {
  uploadCompleted = false;
  isProcessing = false;
  analysisCompleted = false;
  
  processSteps = {
    parsing: false,
    binaryPrediction: false,
    priorityClassification: false,
    groupModulation: false
  };
  
  analysisResults: any[] = [];
  totalProcessed = 0;
  threatsDetected = 0;

  constructor(
    private fb: FormBuilder,
    private analysisService: AnalysisService
  ) {}

  ngOnInit() {}

  onFileUploaded(fileData: any) {
    this.uploadCompleted = true;
    this.startAnalysis(fileData);
  }

  onUploadProgress(progress: number) {
    // Handle upload progress if needed
  }

  async startAnalysis(fileData: any) {
    this.isProcessing = true;
    this.resetProcessSteps();
    
    try {
      // Simulate step-by-step processing
      await this.simulateProcessingStep('parsing', 1000);
      await this.simulateProcessingStep('binaryPrediction', 1500);
      await this.simulateProcessingStep('priorityClassification', 1200);
      await this.simulateProcessingStep('groupModulation', 800);
      
      // Call actual analysis service
      const results = await this.analysisService.analyzeData(fileData).toPromise();
      
      this.analysisResults = results.filteredResults || [];
      this.totalProcessed = results.totalProcessed || 0;
      this.threatsDetected = results.threatsDetected || 0;
      
      this.isProcessing = false;
      this.analysisCompleted = true;
      
    } catch (error) {
      console.error('Analysis failed:', error);
      this.isProcessing = false;
    }
  }

  private async simulateProcessingStep(step: string, delay: number) {
    await new Promise(resolve => setTimeout(resolve, delay));
    this.processSteps[step as keyof typeof this.processSteps] = true;
  }

  private resetProcessSteps() {
    this.processSteps = {
      parsing: false,
      binaryPrediction: false,
      priorityClassification: false,
      groupModulation: false
    };
  }
}

analyse.component.html :
<div class="analysis-page animate-fadeInUp">
    <div class="page-header">
        <h1>Analyse Menace</h1>
        <p>Chargez les donn√©es EDR pour une analyse de s√©curit√© bas√©e sur l'IA</p>
    </div>

    <div class="analysis-workflow">
        <!-- Step 1: File Upload -->
        <div class="workflow-step" [class.completed]="uploadCompleted">
            <div class="step-header">
                <div class="step-number">1</div>
                <h2>Charger Donn√©es EDR</h2>
            </div>
            <app-file-upload (fileUploaded)="onFileUploaded($event)" (uploadProgress)="onUploadProgress($event)">
            </app-file-upload>
        </div>

        <!-- Step 2: Processing -->
        <div class="workflow-step" [class.active]="isProcessing" [class.completed]="analysisCompleted">
            <div class="step-header">
                <div class="step-number">2</div>
                <h2>Analyse IA</h2>
            </div>
            <div class="processing-panel card" *ngIf="isProcessing || analysisCompleted">
                <div class="processing-status">
                    <div class="loading" *ngIf="isProcessing"></div>
                    <div class="process-steps">
                        <div class="process-step" [class.completed]="processSteps.parsing">
                            <span class="step-icon">üìä</span>
                            <span>R√©cup√©ration Donn√©es</span>
                        </div>
                        <div class="process-step" [class.completed]="processSteps.binaryPrediction">
                            <span class="step-icon">ü§ñ</span>
                            <span>Classification Binaire</span>
                        </div>
                        <div class="process-step" [class.completed]="processSteps.priorityClassification">
                            <span class="step-icon">üéØ</span>
                            <span>Priorisation Alertes</span>
                        </div>
                        <div class="process-step" [class.completed]="processSteps.groupModulation">
                            <span class="step-icon">üë•</span>
                            <span>Modulation Priorit√© Groupe</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Results -->
        <div class="workflow-step" [class.active]="analysisCompleted">
            <div class="step-header">
                <div class="step-number">3</div>
                <h2>R√©sultats Analyse</h2>
            </div>
            <app-results-table *ngIf="analysisCompleted" [results]="analysisResults" [totalProcessed]="totalProcessed"
                [threatsDetected]="threatsDetected">
            </app-results-table>
        </div>
    </div>
</div>


analyse.service.ts :
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { map, delay } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AnalysisService {
  private apiUrl = 'http://localhost:8000'; // Backend API URL

  constructor(private http: HttpClient) {}

  analyzeData(fileData: any): Observable<any> {
    // For now, return mock data. In production, this would call the Python backend
    return this.generateMockAnalysis(fileData).pipe(delay(2000));
  }

  private generateMockAnalysis(fileData: any): Observable<any> {
    const mockResults = this.generateMockResults(fileData.data || []);
    
    return of({
      totalProcessed: fileData.data?.length || 0,
      threatsDetected: mockResults.length,
      filteredResults: mockResults,
      processingTime: '2.3s',
      modelVersion: '1.2.0'
    });
  }

  private generateMockResults(data: any[]): any[] {
    const groupPriorities = {
      'executive': 2.5,
      'management': 2.0,
      'developer': 1.5,
      'analyst': 1.3,
      'user': 1.0,
      'contractor': 0.8
    };

    const groups = ['executive', 'management', 'developer', 'analyst', 'user', 'contractor'];
    const severities = ['critical', 'high', 'medium', 'low'];
    const processes = [
      'cmd.exe', 'powershell.exe', 'rundll32.exe', 'svchost.exe', 
      'winword.exe', 'excel.exe', 'chrome.exe', 'firefox.exe'
    ];
    const hostnames = [
      'EXEC-001', 'DEV-WORKSTATION', 'USER-PC-045', 'ANALYST-LAB', 
      'CONTRACTOR-VM', 'MGMT-LAPTOP', 'SEC-STATION'
    ];

    const results = [];
    const numResults = Math.min(50, Math.max(10, Math.floor(data.length * 0.1))); // 10% threat detection rate

    for (let i = 0; i < numResults; i++) {
      const group = groups[Math.floor(Math.random() * groups.length)];
      const severity = severities[Math.floor(Math.random() * severities.length)];
      const confidence = 0.5 + Math.random() * 0.5; // 50-100% confidence for threats
      const basePriority = Math.random();
      
      // Apply group multiplier
      const groupMultiplier = groupPriorities[group as keyof typeof groupPriorities] || 1.0;
      const priorityScore = Math.min(1.0, basePriority * groupMultiplier);
      
      // Determine final priority
      let finalPriority = 'low';
      if (priorityScore >= 0.8) finalPriority = 'high';
      else if (priorityScore >= 0.5) finalPriority = 'medium';
      
      results.push({
        id: i + 1,
        group: group,
        hostname: hostnames[Math.floor(Math.random() * hostnames.length)],
        username: `${group}_user_${Math.floor(Math.random() * 100)}`,
        process_name: processes[Math.floor(Math.random() * processes.length)],
        path: `C:\\Windows\\System32\\${processes[Math.floor(Math.random() * processes.length)]}`,
        alert_severity: severity,
        confidence: confidence,
        basePriority: basePriority,
        groupMultiplier: groupMultiplier,
        priorityScore: priorityScore,
        finalPriority: finalPriority,
        childproc_count: Math.floor(Math.random() * 5),
        netconn_count: Math.floor(Math.random() * 10),
        filemod_count: Math.floor(Math.random() * 20),
        timestamp: new Date(Date.now() - Math.random() * 86400000 * 7), // Last 7 days
        cmdline: `"C:\\Windows\\System32\\${processes[Math.floor(Math.random() * processes.length)]}" -param value`,
        parent_name: 'explorer.exe',
        sensor_id: Math.floor(Math.random() * 1000),
        process_pid: Math.floor(Math.random() * 10000),
        parent_pid: Math.floor(Math.random() * 10000)
      });
    }

    // Sort by priority score descending
    return results.sort((a, b) => b.priorityScore - a.priorityScore);
  }
}

file-upload.component.ts :
import { Component, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as XLSX from 'xlsx';

@Component({
  selector: 'app-file-upload',
  standalone: true,
  styleUrl: "./file-upload.component.css",
  templateUrl: "./file-upload.component.html",
  imports: [CommonModule],
})
export class FileUploadComponent {
  @Output() fileUploaded = new EventEmitter<any>();
  @Output() uploadProgress = new EventEmitter<number>();

  isDragOver = false;
  isUploading = false;
  uploadedFile: File | null = null;
  parsedData: any[] = [];
  parsedColumns: string[] = [];
  uploadProgressValue = 0;

  // EDR fields that we expect to find in the Carbon Black data
  expectedEdrFields = [
    'alert_severity',
    'childproc_count',
    'group',
    'hostname',
    'process_name',
    'cmdline',
    'parent_name',
    'username',
    'path',
    'netconn_count',
    'filemod_count',
    'regmod_count',
    'crossproc_count',
    'last_update',
    'start',
    'sensor_id',
    'cb_server',
    'process_pid',
    'parent_pid',
    'process_md5',
    'parent_md5'
  ];

  detectedEdrFields: Array<{name: string, found: boolean}> = [];

  onDragOver(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    this.isDragOver = true;
  }

  onDragLeave(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    this.isDragOver = false;
  }

  onFileDropped(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    this.isDragOver = false;
    
    const files = event.dataTransfer?.files;
    if (files && files.length > 0) {
      this.processFile(files[0]);
    }
  }

  onFileSelected(event: Event) {
    const target = event.target as HTMLInputElement;
    const files = target.files;
    if (files && files.length > 0) {
      this.processFile(files[0]);
    }
  }

  async processFile(file: File) {
    this.uploadedFile = file;
    this.isUploading = true;
    this.uploadProgressValue = 0;

    try {
      // Simulate upload progress
      for (let i = 0; i <= 100; i += 10) {
        this.uploadProgressValue = i;
        this.uploadProgress.emit(i);
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // Parse the file
      const data = await this.parseExcelFile(file);
      this.parsedData = data;
      this.parsedColumns = data.length > 0 ? Object.keys(data[0]) : [];
      
      // Detect EDR fields
      this.detectEdrFields();
      
      this.isUploading = false;
      
      // Emit the parsed data
      this.fileUploaded.emit({
        file: file,
        data: data,
        columns: this.parsedColumns,
        edrFields: this.detectedEdrFields
      });
      
    } catch (error) {
      console.error('Error processing file:', error);
      this.isUploading = false;
    }
  }

  private parseExcelFile(file: File): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target?.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: 'array' });
          
          // Get the first worksheet
          const worksheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[worksheetName];
          
          // Convert to JSON
          const jsonData = XLSX.utils.sheet_to_json(worksheet);
          resolve(jsonData);
        } catch (error) {
          reject(error);
        }
      };
      
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsArrayBuffer(file);
    });
  }

  private detectEdrFields() {
    this.detectedEdrFields = this.expectedEdrFields.map(field => ({
      name: field,
      found: this.parsedColumns.some(col => 
        col.toLowerCase().includes(field.toLowerCase()) ||
        field.toLowerCase().includes(col.toLowerCase())
      )
    }));
  }

  formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}

file-upload.component.html :
<div class="file-upload-container">
    <div class="file-upload" [class.drag-over]="isDragOver" (dragover)="onDragOver($event)"
        (dragleave)="onDragLeave($event)" (drop)="onFileDropped($event)" (click)="fileInput.click()">

        <input #fileInput type="file" accept=".xlsx,.xls,.csv" (change)="onFileSelected($event)" style="display: none;">

        <div class="upload-content">
            <div class="upload-icon">üìä</div>
            <h3>Charger Fichier EDR</h3>
            <p>D√©posez votre fichier Excel ici ou cliquez pour parcourir</p>
            <div class="supported-formats">
                <span class="format-badge">.XLSX</span>
                <span class="format-badge">.XLS</span>
                <span class="format-badge">.CSV</span>
            </div>
        </div>
    </div>

    <div class="upload-progress" *ngIf="isUploading">
        <div class="progress-bar">
            <div class="progress-fill" [style.width.%]="uploadProgress"></div>
        </div>
        <p>Tratement fichier... {{ uploadProgress }}%</p>
    </div>

    <div class="file-info" *ngIf="uploadedFile">
        <div class="file-details card">
            <h4>Information sur fichier</h4>
            <div class="file-stats">
                <div class="stat">
                    <span class="label">Nom:</span>
                    <span class="value">{{ uploadedFile.name }}</span>
                </div>
                <div class="stat">
                    <span class="label">Taille:</span>
                    <span class="value">{{ formatFileSize(uploadedFile.size) }}</span>
                </div>
                <div class="stat">
                    <span class="label">Lignes:</span>
                    <span class="value">{{ parsedData.length }}</span>
                </div>
                <div class="stat">
                    <span class="label">Colonnes:</span>
                    <span class="value">{{ parsedColumns.length }}</span>
                </div>
            </div>

            <div class="detected-fields">
                <h5>Champs EDR D√©tect√©s</h5>
                <div class="fields-grid">
                    <span *ngFor="let field of detectedEdrFields" class="field-badge" [class.found]="field.found">
                        {{ field.name }}
                        <span class="field-status">{{ field.found ? '‚úì' : '‚úó' }}</span>
                    </span>
                </div>
            </div>
        </div>
    </div>
</div>


result-table.component.ts :
import { Component, Input, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-results-table',
  standalone: true,
  templateUrl:"results-table.component.html",
  styleUrl : './results-table.component.css',
  imports: [CommonModule],

})
export class ResultsTableComponent implements OnInit {
  @Input() results: any[] = [];
  @Input() totalProcessed: number = 0;
  @Input() threatsDetected: number = 0;

  filteredResults: any[] = [];
  paginatedResults: any[] = [];
  selectedPriority = 'all';
  currentPage = 1;
  itemsPerPage = 10;
  totalPages = 1;

  ngOnInit() {
    this.filterByPriority('all');
  }

  ngOnChanges() {
    this.filterByPriority(this.selectedPriority);
  }

  filterByPriority(priority: string) {
    this.selectedPriority = priority;
    
    if (priority === 'all') {
      this.filteredResults = [...this.results];
    } else {
      this.filteredResults = this.results.filter(result => 
        result.finalPriority === priority
      );
    }
    
    // Sort by priority score (descending)
    this.filteredResults.sort((a, b) => b.priorityScore - a.priorityScore);
    
    this.currentPage = 1;
    this.updatePagination();
  }

  updatePagination() {
    this.totalPages = Math.ceil(this.filteredResults.length / this.itemsPerPage);
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    this.paginatedResults = this.filteredResults.slice(startIndex, endIndex);
  }

  goToPage(page: number) {
    if (page >= 1 && page <= this.totalPages) {
      this.currentPage = page;
      this.updatePagination();
    }
  }

  getPageNumbers(): number[] {
    const pages = [];
    const maxPages = 5;
    const startPage = Math.max(1, this.currentPage - Math.floor(maxPages / 2));
    const endPage = Math.min(this.totalPages, startPage + maxPages - 1);
    
    for (let i = startPage; i <= endPage; i++) {
      pages.push(i);
    }
    
    return pages;
  }

  getPriorityCount(priority: string): number {
    return this.results.filter(result => result.finalPriority === priority).length;
  }

  getConfidenceClass(confidence: number): string {
    if (confidence >= 0.8) return 'high';
    if (confidence >= 0.6) return 'medium';
    return 'low';
  }

  showDetails(result: any) {
    // Implement details modal or navigation
    console.log('Show details for:', result);
  }

  trackByIndex(index: number, item: any): number {
    return index;
  }
}

results-table.component.html

<div class="results-container">
    <div class="results-header">
        <div class="results-stats grid grid-3">
            <div class="stat-card card">
                <div class="stat-icon">üìä</div>
                <div class="stat-content">
                    <h3>{{ totalProcessed }}</h3>
                    <p>Total Lignes</p>
                </div>
            </div>

            <div class="stat-card card priority-high">
                <div class="stat-icon">üö®</div>
                <div class="stat-content">
                    <h3>{{ threatsDetected }}</h3>
                    <p>Menaces D√©tect√©es</p>
                </div>
            </div>

            <div class="stat-card card priority-low">
                <div class="stat-icon">‚úÖ</div>
                <div class="stat-content">
                    <h3>{{ ((threatsDetected / totalProcessed) * 100).toFixed(1) }}%</h3>
                    <p>Taux D√©tection</p>
                </div>
            </div>
        </div>

        <div class="filter-controls">
            <div class="priority-filters">
                <button class="filter-btn" [class.active]="selectedPriority === 'all'"
                    (click)="filterByPriority('all')">
                    Toutes ({{ filteredResults.length }})
                </button>
                <button class="filter-btn priority-high" [class.active]="selectedPriority === 'high'"
                    (click)="filterByPriority('high')">
                    Haute ({{ getPriorityCount('high') }})
                </button>
                <button class="filter-btn priority-medium" [class.active]="selectedPriority === 'medium'"
                    (click)="filterByPriority('medium')">
                    Moyenne ({{ getPriorityCount('medium') }})
                </button>
                <button class="filter-btn priority-low" [class.active]="selectedPriority === 'low'"
                    (click)="filterByPriority('low')">
                    Basse ({{ getPriorityCount('low') }})
                </button>
            </div>
        </div>
    </div>

    <div class="results-table-container">
        <div class="table-wrapper">
            <table class="results-table">
                <thead>
                    <tr>
                        <th>Priorit√©</th>
                        <th>Groupe</th>
                        <th>Machine</th>
                        <th>Processus</th>
                        <th>Gravit√© Alerte</th>
                        <th>Confiance</th>
                        <th>D√©tails</th>
                    </tr>
                </thead>
                <tbody>
                    <tr *ngFor="let result of paginatedResults; trackBy: trackByIndex"
                        class="result-row animate-fadeInUp" [class]="'priority-' + result.finalPriority">
                        <td>
                            <div class="priority-indicator">
                                <span class="priority-badge" [class]="'priority-' + result.finalPriority">
                                    {{ result.finalPriority.toUpperCase() }}
                                </span>
                                <div class="priority-score">{{ (result.priorityScore * 100).toFixed(0) }}%</div>
                            </div>
                        </td>
                        <td>
                            <div class="group-info">
                                <span class="group-name">{{ result.group }}</span>
                                <span class="group-multiplier">√ó{{ result.groupMultiplier }}</span>
                            </div>
                        </td>
                        <td>
                            <div class="host-info">
                                <span class="hostname">{{ result.hostname }}</span>
                                <span class="username">{{ result.username }}</span>
                            </div>
                        </td>
                        <td>
                            <div class="process-info">
                                <span class="process-name">{{ result.process_name }}</span>
                                <span class="process-path">{{ result.path }}</span>
                            </div>
                        </td>
                        <td>
                            <span class="severity-badge" [class]="'severity-' + result.alert_severity">
                                {{ result.alert_severity }}
                            </span>
                        </td>
                        <td>
                            <div class="confidence-meter">
                                <div class="confidence-bar">
                                    <div class="confidence-fill" [style.width.%]="result.confidence * 100"
                                        [class]="getConfidenceClass(result.confidence)"></div>
                                </div>
                                <span class="confidence-value">{{ (result.confidence * 100).toFixed(1) }}%</span>
                            </div>
                        </td>
                        <td>
                            <button class="details-btn btn" (click)="showDetails(result)">
                                Voir D√©tails
                            </button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="pagination" *ngIf="totalPages > 1">
            <button class="page-btn" [disabled]="currentPage === 1" (click)="goToPage(currentPage - 1)">
                ‚Üê Pr√©c√©dent
            </button>

            <div class="page-numbers">
                <button *ngFor="let page of getPageNumbers()" class="page-btn" [class.active]="page === currentPage"
                    (click)="goToPage(page)">
                    {{ page }}
                </button>
            </div>

            <button class="page-btn" [disabled]="currentPage === totalPages" (click)="goToPage(currentPage + 1)">
                Suivant ‚Üí
            </button>
        </div>
    </div>
</div>


main.py :
from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import pandas as pd
import numpy as np
import io
from typing import List, Dict, Any
import joblib
import logging
from datetime import datetime
import uvicorn

# Mock ML models for demonstration
class MockBinaryClassifier:
    """Mock binary classifier that simulates threat detection"""
    
    def predict_proba(self, X):
        """Return probability scores for binary classification"""
        # Simulate realistic probability distribution
        n_samples = len(X)
        # Most samples will be benign (low probability), some will be threats
        probs = np.random.beta(2, 8, n_samples)  # Skewed towards low values
        # Add some high-probability threats
        threat_indices = np.random.choice(n_samples, size=int(n_samples * 0.1), replace=False)
        probs[threat_indices] = np.random.beta(8, 2, len(threat_indices))  # High probability threats
        
        # Return probabilities for [benign, threat] classes
        return np.column_stack([1 - probs, probs])

class MockPriorityClassifier:
    """Mock priority classifier that assigns priority levels"""
    
    def predict_proba(self, X):
        """Return probability scores for priority classification"""
        n_samples = len(X)
        
        # Create probability distribution for [low, medium, high] priority
        priorities = []
        for _ in range(n_samples):
            # Simulate realistic priority distribution
            rand = np.random.random()
            if rand < 0.6:  # 60% low priority
                probs = [0.7 + np.random.random() * 0.25, 
                        0.15 + np.random.random() * 0.1, 
                        0.05 + np.random.random() * 0.1]
            elif rand < 0.85:  # 25% medium priority
                probs = [0.2 + np.random.random() * 0.2, 
                        0.5 + np.random.random() * 0.3, 
                        0.15 + np.random.random() * 0.15]
            else:  # 15% high priority
                probs = [0.1 + np.random.random() * 0.1, 
                        0.2 + np.random.random() * 0.2, 
                        0.6 + np.random.random() * 0.3]
            
            # Normalize probabilities
            total = sum(probs)
            probs = [p / total for p in probs]
            priorities.append(probs)
        
        return np.array(priorities)

# Initialize FastAPI app
app = FastAPI(
    title="Cyber EDR Analysis API",
    description="AI-powered security analysis for VMware Carbon Black EDR data",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:4200"],  # Angular dev server
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize mock models
binary_model = MockBinaryClassifier()
priority_model = MockPriorityClassifier()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Expected EDR fields for Carbon Black data
EXPECTED_EDR_FIELDS = [
    'alert_severity', 'childproc_count', 'group', 'hostname', 'process_name',
    'cmdline', 'parent_name', 'username', 'path', 'netconn_count',
    'filemod_count', 'regmod_count', 'crossproc_count', 'last_update',
    'start', 'sensor_id', 'cb_server', 'process_pid', 'parent_pid',
    'process_md5', 'parent_md5'
]

# Group priority multipliers
GROUP_MULTIPLIERS = {
    'executive': 2.5,
    'management': 2.0,
    'developer': 1.5,
    'analyst': 1.3,
    'user': 1.0,
    'contractor': 0.8
}

def extract_features(df: pd.DataFrame) -> np.ndarray:
    """Extract numerical features from EDR data for ML models"""
    features = []
    
    for _, row in df.iterrows():
        feature_vector = []
        
        # Numerical features
        feature_vector.extend([
            row.get('childproc_count', 0),
            row.get('netconn_count', 0),
            row.get('filemod_count', 0),
            row.get('regmod_count', 0),
            row.get('crossproc_count', 0),
            row.get('process_pid', 0),
            row.get('parent_pid', 0),
            row.get('sensor_id', 0)
        ])
        
        # Categorical features (encoded)
        severity_map = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
        feature_vector.append(severity_map.get(str(row.get('alert_severity', '')).lower(), 0))
        
        # Process name features (simple encoding)
        process_name = str(row.get('process_name', '')).lower()
        suspicious_processes = ['cmd.exe', 'powershell.exe', 'rundll32.exe', 'regsvr32.exe']
        feature_vector.append(1 if any(proc in process_name for proc in suspicious_processes) else 0)
        
        # Command line features
        cmdline = str(row.get('cmdline', '')).lower()
        suspicious_keywords = ['download', 'invoke', 'bypass', 'hidden', 'encoded']
        feature_vector.append(sum(1 for keyword in suspicious_keywords if keyword in cmdline))
        
        # Path features
        path = str(row.get('path', '')).lower()
        system_paths = ['system32', 'syswow64']
        feature_vector.append(1 if any(sys_path in path for sys_path in system_paths) else 0)
        
        features.append(feature_vector)
    
    return np.array(features)

def normalize_group_name(group: str) -> str:
    """Normalize group names to match expected categories"""
    group_lower = str(group).lower()
    
    if any(keyword in group_lower for keyword in ['exec', 'ceo', 'president', 'director']):
        return 'executive'
    elif any(keyword in group_lower for keyword in ['manager', 'lead', 'supervisor']):
        return 'management'
    elif any(keyword in group_lower for keyword in ['dev', 'engineer', 'programmer']):
        return 'developer'
    elif any(keyword in group_lower for keyword in ['analyst', 'security', 'admin']):
        return 'analyst'
    elif any(keyword in group_lower for keyword in ['contract', 'temp', 'vendor']):
        return 'contractor'
    else:
        return 'user'

@app.post("/analyze")
async def analyze_edr_data(file: UploadFile = File(...)):
    """Analyze uploaded EDR data file"""
    try:
        logger.info(f"Received file: {file.filename}")
        
        # Read uploaded file
        contents = await file.read()
        
        # Parse Excel/CSV file
        try:
            if file.filename.endswith('.csv'):
                df = pd.read_csv(io.StringIO(contents.decode('utf-8')))
            else:
                df = pd.read_excel(io.BytesIO(contents))
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Error parsing file: {str(e)}")
        
        logger.info(f"Parsed dataframe with shape: {df.shape}")
        
        # Extract features for ML models
        features = extract_features(df)
        
        # Step 1: Binary classification (threat detection)
        binary_probs = binary_model.predict_proba(features)
        threat_probs = binary_probs[:, 1]  # Probability of being a threat
        
        # Filter records predicted as threats (threshold = 0.5)
        threat_mask = threat_probs >= 0.5
        threat_indices = np.where(threat_mask)[0]
        
        logger.info(f"Detected {len(threat_indices)} potential threats out of {len(df)} records")
        
        if len(threat_indices) == 0:
            return JSONResponse({
                "totalProcessed": len(df),
                "threatsDetected": 0,
                "filteredResults": [],
                "processingTime": "1.2s",
                "modelVersion": "1.0.0"
            })
        
        # Step 2: Priority classification for detected threats
        threat_features = features[threat_indices]
        priority_probs = priority_model.predict_proba(threat_features)
        
        # Build results
        results = []
        for i, idx in enumerate(threat_indices):
            row = df.iloc[idx]
            
            # Get priority probabilities [low, medium, high]
            low_prob, med_prob, high_prob = priority_probs[i]
            base_priority_score = high_prob  # Use high priority probability as base score
            
            # Apply group modulation
            group = normalize_group_name(row.get('group', 'user'))
            group_multiplier = GROUP_MULTIPLIERS.get(group, 1.0)
            final_priority_score = min(1.0, base_priority_score * group_multiplier)
            
            # Determine final priority category
            if final_priority_score >= 0.8:
                final_priority = 'high'
            elif final_priority_score >= 0.5:
                final_priority = 'medium'
            else:
                final_priority = 'low'
            
            # Create result record
            result = {
                'id': int(idx),
                'group': group,
                'hostname': str(row.get('hostname', 'Unknown')),
                'username': str(row.get('username', 'Unknown')),
                'process_name': str(row.get('process_name', 'Unknown')),
                'path': str(row.get('path', 'Unknown')),
                'alert_severity': str(row.get('alert_severity', 'medium')),
                'confidence': float(threat_probs[idx]),
                'basePriority': float(base_priority_score),
                'groupMultiplier': float(group_multiplier),
                'priorityScore': float(final_priority_score),
                'finalPriority': final_priority,
                'childproc_count': int(row.get('childproc_count', 0)),
                'netconn_count': int(row.get('netconn_count', 0)),
                'filemod_count': int(row.get('filemod_count', 0)),
                'timestamp': datetime.now().isoformat(),
                'cmdline': str(row.get('cmdline', '')),
                'parent_name': str(row.get('parent_name', 'Unknown')),
                'sensor_id': int(row.get('sensor_id', 0)),
                'process_pid': int(row.get('process_pid', 0)),
                'parent_pid': int(row.get('parent_pid', 0))
            }
            results.append(result)
        
        # Sort results by priority score (descending)
        results.sort(key=lambda x: x['priorityScore'], reverse=True)
        
        logger.info(f"Analysis complete. Returning {len(results)} threat records")
        
        return JSONResponse({
            "totalProcessed": len(df),
            "threatsDetected": len(results),
            "filteredResults": results,
            "processingTime": "2.1s",
            "modelVersion": "1.0.0"
        })
        
    except Exception as e:
        logger.error(f"Analysis error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

@app.get("/config")
async def get_config():
    """Get current configuration"""
    return {
        "groupMultipliers": GROUP_MULTIPLIERS,
        "expectedFields": EXPECTED_EDR_FIELDS,
        "modelInfo": {
            "binaryModel": "MockBinaryClassifier v1.0",
            "priorityModel": "MockPriorityClassifier v1.0"
        }
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)


